# lazy
Python library for rapidly developing lazy interfaces.

By deferring the execution of your code until the last possible moment (when you actually request the data with `.get()`)
you can optimize its execution while preserving simple imperative semantics.

Optimizations include things like
- Minimal execution by tracing dependencies and only execution operations *needed* to produce the data
- Automatic output caching and invalidation
- Automatic parallelization of the induced dataflow graph

# How it works

This library works by modifying annotated functions to record when they were called and their inputs and outputs.
Once `.get()` is invoked on an output of one of these functions a minimal dataflow graph is generated by inspecting
all the dependencies (including cached outputs).  This dataflow graph can optionally be automatically parallelized.

Try it out yourself!

# Usage

Decorate synchronous functions with `@lazy.synchronous`

````python
@lazy.synchronous
def Square(x):
    time.sleep(0.1)
    return x ** 2

@lazy.synchronous
def Mul(x, y):
    time.sleep(0.1)
    return x * y
````

Write your program and access the output of annotated functions with `.get()`

````python
a = Square(2)
b = Square(a)
# The code isn't run until you call .get()
print(b.get())
````

Run things in parallel automatically with `lazy.parallelize = True`

````python
lazy.parallelize = True

a = Square(2)
b = Square(3)
c = Mul(a, b)

t = time.time()
print(c.get())
print(time.time() - t)
# Should only take 0.2s instead of 0.3s by automatic parallelism
````

