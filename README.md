# lazy
Python library for rapidly developing lazy interfaces.  This is currently a prototype built for playing with the paradigm.

By deferring the execution of your code until the last possible moment (when you actually request the data with `.get()`)
you can optimize its execution while preserving simple imperative semantics.

Optimizations include things like
- Minimal execution by tracing dependencies and only execution operations *needed* to produce the data
- Automatic output caching and invalidation
- Automatic parallelization of the induced dataflow graph

## How it works

This library works by modifying annotated functions to record when they were called and their inputs and outputs.
Once `.get()` is invoked on an output a minimal dataflow graph is generated by inspecting
all of its dependencies (including cached outputs).  This dataflow graph can optionally be automatically parallelized.

A key requirement of this library is that all annotated functions be stateless and synchronous.

See the execution example at the bottom for details, or try it out yourself!

## Usage

Decorate *stateless and synchronous* functions with `@lazy.synchronous`

````python
import lazy

@lazy.synchronous
def Square(x):
    time.sleep(0.1)
    return x ** 2

@lazy.synchronous
def Mul(x, y):
    time.sleep(0.1)
    return x * y

@lazy.synchronous
def Add(x, y):
    time.sleep(0.1)
    return x + y
````

Write your program and access the output of annotated functions with `.get()`

````python
a = Square(2)
b = Square(3)
c = Mul(a, b)
d = Add(a, b)

t = time.time()
# The code isn't run until you call .get()
print(c.get())
print(time.time() - t)

t = time.time()
print(d.get())
print(time.time() - t)
````

Run things in parallel automatically with `lazy.parallelize = True`

````python
lazy.parallelize = True

a = Square(2)
b = Square(3)
c = Mul(a, b)

t = time.time()
print(c.get())
print(time.time() - t)
# Should only take 0.2s instead of 0.3s by automatic parallelism
````

## TODO

- Support functions that operate in-place
- Add asynchronuos API
- Support maximal trace length (to automatically force calls to `get()`)

## Execution example

Below was generated with calls to `lazy.draw()`.

Before calling `c.get()` in the above example we can see that only the input data is valid
![](https://i.imgur.com/8jetAUY.png)

After calling `c.get()` we can see that only `Mul` was invoked (and not `Add`)
![](https://i.imgur.com/1MygD3H.png)

Once we call `d.get()` `Add` is executed using the cached intermediate values calculated when we called `c.get()`
![](https://i.imgur.com/2Hnf6XL.png)
